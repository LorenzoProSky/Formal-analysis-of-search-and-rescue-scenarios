<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// Global declaration
// System features
const int N_ROW = 10;
const int N_COL = 8;
const int N_DRONE = 2;
const int N_FIRST_RESPONDER = 2;
const int N_CIVILIAN = 3;

const int drone_ids[N_DRONE] = {0,1};
const int drone_nvs[N_DRONE] = {2,2};

const int civilian_ids[N_CIVILIAN] = {0,1,2}; // 0 - N_CIVILIAN - 1
const int civilian_tvs[N_CIVILIAN] = {2,2,2};
const int civilians_tzrs[N_CIVILIAN] = {2,2,2};

const int first_responder_ids[N_FIRST_RESPONDER] = {0,1}; // 0 - N_FIRST_RESPONDER - 1
const int first_responder_tfrs[N_FIRST_RESPONDER] = {2,2};

// ---- POSITIONS ----
// Cell value type
const int FREE = 0;
const int SAFE = 0;
const int CASUALITY = 0;
const int FIRE = 1;
const int FIRST_RESPONDER = 2;
const int CIVILIAN = 3;
const int EXIT = 4;
const int ZERO_RESPONDER = 5;
const int IN_ASSISTANCE = 6;
const int VICTIM = 7;
const int IN_CONTACT = 8;

typedef struct {
    int r;
    int c;
} position;

// arrays of positions of the entities
position c_position[N_CIVILIAN]; // civilians positions
position d_position[N_DRONE]; // drones positions
position f_position[N_FIRST_RESPONDER]; // first responders positions

// Map initialization of the FIRE and EXITS: the top left cell is at position (0,0) and the bottom right is at (N_ROW - 1, N_COL - 1)
int map[N_ROW][N_COL] = {
        {0,0,0,0,0,0,0,0},
        {0,1,1,0,0,0,0,0},
        {0,1,1,0,0,0,0,0},
        {0,0,1,1,0,0,0,0},
        {0,0,0,0,0,0,0,0}, 
        {0,0,0,0,0,0,0,0},
        {0,0,0,0,0,0,0,0},
        {0,0,0,0,0,0,0,0},
        {0,0,0,0,0,0,0,0},
        {0,0,0,0,0,0,4,4}
 };

// temp variables for initialization of positions
// drones
position d0;
position d1;

// civialians
position c0;
position c1;
position c2;

// first responders
position f0;
position f1;

// Initialize the positions of drones and people
void initializePositions() {

    // initialize drone positions
    d0.r = 0;
    d0.c = 2;
    d1.r = 0;
    d1.c = 5;
    d_position[0] = d0;
    d_position[1] = d1;

    // initialize civilian positions
    c0.r = 2;
    c0.c = 3;
    c1.r = 5;
    c1.c = 5;
    c2.r = 8;
    c2.c = 5;
    c_position[0] = c0;
    c_position[1] = c1;
    c_position[2] = c2;

    // initialize first responders positions
    f0.r = 2;
    f0.c = 5;
    f1.r = 7;
    f1.c = 2;
    f_position[0] = f0;
    f_position[1] = f1;

}

// ---- MOVEMENT ----
// Directions
const int UP = 0;
const int RIGHT = 1;
const int DOWN = 2;
const int LEFT = 3;

// checks if the cell in the provided direction from the current_position is free and within bounds
bool canMove(int direction, position current_position) {

    int new_r = current_position.r;
    int new_c = current_position.c;

    // Calculate new position based on direction
    if (direction == UP) new_r++;
    else if (direction == RIGHT) new_c++;
    else if (direction == DOWN) new_r--;
    else if (direction == LEFT) new_c--;

    // Check if new position is within grid bounds
    if (new_r &lt; 0 || new_r &gt;= N_ROW || new_c &lt; 0 || new_c &gt;= N_COL) 
        return false;

    // Check if new position is empty in the grid
    if (map[new_r][new_c] != 0) 
        return false;

    return true;
}

// returns a new position given a old_position and a direction
position getNewPosition(int direction, position old_position){
    position new_position;

    int new_r = old_position.r;
    int new_c = old_position.c;

    // Calculate new position based on direction
    if (direction == UP) new_r++;
    else if (direction == RIGHT) new_c++;
    else if (direction == DOWN) new_r--;
    else if (direction == LEFT) new_c--;

    
    new_position.r = new_r;
    new_position.c = new_c;

    return new_position;
}

void updateMap(int value, position cell){
    map[cell.r][cell.c] = value;
}

// Helper function to calculate Manhattan distance
int getDistance(position pos1, position pos2) {
    int dr = pos1.r - pos2.r;
    int dc = pos1.c - pos2.c;
    return (dr &gt; 0 ? dr : -dr) + (dc &gt; 0 ? dc : -dc);
}

// gets the distance between 2 civialians indipendent of their states
int getDistanceCC(int c1_id, int c2_id) {
    position position_c1 = c_position[c1_id];
    position position_c2 = c_position[c2_id];
    return getDistance(position_c1, position_c2);
}

// gets the distance between a civialian and a first responder indipendent of their states
int getDistanceCF(int c_id, int fr_id){
    position position_c = c_position[c_id];
    position position_fr = f_position[fr_id];
    return getDistance(position_c, position_fr);
}


// ---- COMMUNICATION ----
// Channel declaration
broadcast chan initialization_completed;
urgent chan drone_msg_zero_responder[N_CIVILIAN];
urgent chan drone_msg_contact_first_responder[N_CIVILIAN];
urgent chan rescue_msg[N_CIVILIAN];
chan rescue_completed_msg[N_CIVILIAN];
chan casualty_msg[N_CIVILIAN];
urgent chan civilian_contact_msg[N_FIRST_RESPONDER];

typedef struct {
    int target_id;
    // Implicit recipient_id
} msg_single;
typedef struct {
    msg_single message;
} inbox_single;
struct {
    inbox_single inboxes[N_CIVILIAN];
} global_drone_communication;

void sendMessageSingle(int target_id, int recipient_id) {
    msg_single new_message = {target_id};
    global_drone_communication.inboxes[recipient_id].message = new_message;
    // Cannot be conflicts since, only 1 drone at a time makes a decision
}
int readMessageSingle(int recipient_id) {
    msg_single recipient_message = global_drone_communication.inboxes[recipient_id].message;
    msg_single empty_message = {-1};
    global_drone_communication.inboxes[recipient_id].message = empty_message;
    return recipient_message.target_id;
}

typedef struct {
    int victim_id;
    int survivor_id;
    // Implicit recipient_id
} msg_double;
typedef struct {
    msg_double message;
} inbox_double;
struct {
    inbox_double inboxes[N_FIRST_RESPONDER];
} global_civilian_contact_communication;

void sendMessageDouble(int victim_id, int survivor_id, int recipient_id) {
    msg_double new_message = {victim_id, survivor_id};
    global_civilian_contact_communication.inboxes[recipient_id - N_FIRST_RESPONDER].message = new_message;
}
msg_double readMessageDouble(int recipient_id) {
    msg_double recipient_message = global_civilian_contact_communication.inboxes[recipient_id - N_FIRST_RESPONDER].message;
    // Inbox cleanup moved to utilizing method due to initiliazition side-effect error
    return recipient_message;
}

void initializeGlobalCommunication()  {
    msg_single empty_message_single = {-1};
    msg_double empty_message_double = {-1,-1};
    for (i : int[0,N_CIVILIAN - 1]) {
        global_drone_communication.inboxes[i].message = empty_message_single;
    }
    for (i : int[0,N_FIRST_RESPONDER - 1]) {
        global_civilian_contact_communication.inboxes[i].message = empty_message_double;
    }
}

// ---- HELPER FUNCTIONS FOR THE QUERIES ----
// checks that the positions of the civialins are different
bool areDifferent(){

  position p;
  for (i : int[0,N_CIVILIAN-1]) {
    p = c_position[i];
    for (j : int[0,N_CIVILIAN-1]) {
        if(p.r == c_position[j].r &amp;&amp; p.c == c_position[j].c &amp;&amp; i != j &amp;&amp; p.r != 0 &amp;&amp; p.c != 0) {
            return false;
        }
    }
  }
  return true;

}</declaration>
	<template>
		<name>Initializer</name>
		<declaration>void initialization() {
    initializePositions();
    initializeGlobalCommunication();
}</declaration>
		<location id="id0" x="-561" y="-68">
			<committed/>
		</location>
		<location id="id1" x="-272" y="-68">
		</location>
		<init ref="id0"/>
		<transition id="id2">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-527" y="-102">initialization_completed!</label>
			<label kind="assignment" x="-527" y="-119">initialization()</label>
		</transition>
	</template>
	<template>
		<name x="5" y="5">Drone</name>
		<parameter>const int drone_id, const int nv</parameter>
		<declaration>// ---- Private drone's variables ----
int detected_survivor_id = -1;
int detected_victim_id = -1;
int direction = 1; // current movement direction of the drone (1 = UP, -1 = DOWN)

// ---- Private drone's funtions ----

// Drone moving policy
void move() { 
    
    // get current drone position
    position current_position = d_position[drone_id];
    
    // if the drone is at the top or the bottom of the grid change direction
    if (current_position.r == N_ROW - 1) {
        direction = -1;  
    } else if (current_position.r == 0) {
        direction = 1;
    }

    // fly in the direction 
    d_position[drone_id].r = d_position[drone_id].r + direction; // update the drone's position  
   
}

// Look for the survivor, victim and first responder in range and update the local variables.
// If more then one civilian, victim or first responder are detected only the closest ones to the Drones are saved.
void detect() {
    int closest_survivor_distance = drone_nvs[drone_id] + 1; // Initialize with a distance greater than Nv
    int closest_victim_distance = drone_nvs[drone_id] + 1;
    position current_position = d_position[drone_id];
    int row, col, distance, i;
    int nv = drone_nvs[drone_id];
    
    // Scan the entire grid, but only consider cells within Nv distance
    for (row = 0; row &lt; N_ROW; row++) {
        for (col = 0; col &lt; N_COL; col++) {
            position cell_position = {row, col};
            distance = getDistance(current_position, cell_position);
            
            // Only process cells within drone_Nv distance
            if (distance &lt;= nv) {
                // Check for survivors (CIVILIAN)
                if (map[row][col] == CIVILIAN) {
                    for (i = 0; i &lt; N_FIRST_RESPONDER; i++) {
                        if (c_position[i].r == row &amp;&amp; c_position[i].c == col) {
                            if (distance &lt; closest_survivor_distance) {
                                detected_survivor_id = i;
                                closest_survivor_distance = distance;
                            }
                            //break;
                        }
                    } 
                }
                // Check for victims (VICTIM)
                else if (map[row][col] == VICTIM) {
                    for (i = 0; i &lt; N_CIVILIAN; i++) {
                        if (c_position[i].r == row &amp;&amp; c_position[i].c == col) {
                            if (distance &lt; closest_victim_distance) {
                                detected_victim_id = i;
                                closest_victim_distance = distance;
                            }
                            //break;
                        }
                    }
                }
            }
        }
    }
}

bool foundCivilians() {
    if(detected_survivor_id != -1 &amp;&amp; detected_victim_id != -1) return true;
    return false;
}

void prepareNewContact() {
    detected_survivor_id = -1;
    detected_victim_id = -1;
}</declaration>
		<location id="id3" x="-2082" y="-1521">
		</location>
		<location id="id4" x="-1810" y="-1521">
			<name x="-1853" y="-1513">Idle</name>
		</location>
		<location id="id5" x="-1249" y="-1521">
			<committed/>
		</location>
		<location id="id6" x="-1249" y="-1674">
			<name x="-1232" y="-1700">Communicating</name>
			<committed/>
		</location>
		<location id="id7" x="-1249" y="-1360">
			<name x="-1232" y="-1385">Patrolling</name>
		</location>
		<location id="id8" x="-1810" y="-1674">
			<committed/>
		</location>
		<init ref="id3"/>
		<transition id="id9">
			<source ref="id6"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-1742" y="-1759">drone_msg_zero_responder[detected_survivor_id]!</label>
			<label kind="assignment" x="-1785" y="-1742">sendMessageSingle(detected_victim_id,detected_survivor_id)</label>
			<nail x="-1530" y="-1717"/>
		</transition>
		<transition id="id10">
			<source ref="id6"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-1776" y="-1632">drone_msg_contact_first_responder[detected_survivor_id]!</label>
			<label kind="assignment" x="-1785" y="-1615">sendMessageSingle(detected_victim_id,detected_survivor_id)</label>
			<nail x="-1530" y="-1632"/>
		</transition>
		<transition id="id11">
			<source ref="id8"/>
			<target ref="id4"/>
			<label kind="assignment" x="-1989" y="-1615">prepareNewContact()</label>
		</transition>
		<transition id="id12">
			<source ref="id7"/>
			<target ref="id4"/>
			<label kind="assignment" x="-1564" y="-1385">move()</label>
			<nail x="-1810" y="-1360"/>
		</transition>
		<transition id="id13">
			<source ref="id5"/>
			<target ref="id7"/>
			<label kind="guard" x="-1241" y="-1445">!foundCivilians()</label>
		</transition>
		<transition id="id14">
			<source ref="id5"/>
			<target ref="id6"/>
			<label kind="guard" x="-1241" y="-1598">foundCivilians()</label>
		</transition>
		<transition id="id15">
			<source ref="id4"/>
			<target ref="id5"/>
			<label kind="assignment" x="-1572" y="-1547">detect()</label>
		</transition>
		<transition id="id16">
			<source ref="id3"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-2057" y="-1547">initialization_completed?</label>
		</transition>
	</template>
	<template>
		<name>FirstResponder</name>
		<parameter>const int first_responder_id, const int tfr</parameter>
		<declaration>// ---- Private First-Responder's variables ----
clock x;
int detected_victim_id = -1;
int contacting_survivor_id = -1;

// ---- Private First-Responder's functions ----

void move(int direction){
    position current_position = f_position[first_responder_id];
    position new_position = getNewPosition(direction, current_position);
    // update array
    f_position[first_responder_id] = new_position;
    // update map
    updateMap(FREE, current_position);
    updateMap(FIRST_RESPONDER, new_position);
}

// Checks if there is a victim within a 1-cell range.
// If there is it saves its id in detected_victim_id.
// If there are more then one victim within the 1-cell range
// the choice of victim id to save is random.
void detect() {
    position current_position = f_position[first_responder_id];
    int row, col;
    
    // Check all adjacent cells (including diagonals)
    for (row = current_position.r - 1; row &lt;= current_position.r + 1; row++) {
        for (col = current_position.c - 1; col &lt;= current_position.c + 1; col++) {
            
            // Check if the cell is within the grid boundaries
            if (row &gt;= 0 &amp;&amp; row &lt; N_ROW &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; N_COL) {
                // Check if the cell contains a victim
                if (map[row][col] == VICTIM) {
                    // Find which civilian is at this position
                    int i;
                    for (i = 0; i &lt; N_CIVILIAN; i++) {
                        if (c_position[i].r == row &amp;&amp; c_position[i].c == col) {
                            detected_victim_id = i;
                           return; // Exit the function after finding the first victim
                        }
                    }
                }
            }
        }
    }
}

bool foundVictim() {
    if(detected_victim_id != -1) return true;
    return false;
}

void prepareNewRescue() {
    detected_victim_id = -1;
    contacting_survivor_id = -1;
}

void readMessageFromContactingCivilian() {
    msg_double message = readMessageDouble(first_responder_id);
    msg_double empty_message = {-1,-1};
    detected_victim_id = message.victim_id;
    contacting_survivor_id = message.survivor_id;
    global_civilian_contact_communication.inboxes[first_responder_id - N_FIRST_RESPONDER].message = empty_message; // Inbox cleanup
}</declaration>
		<location id="id17" x="-1487" y="-1793">
		</location>
		<location id="id18" x="-1020" y="-1606">
			<committed/>
		</location>
		<location id="id19" x="-1300" y="-1606">
			<name x="-1351" y="-1598">Idle</name>
		</location>
		<location id="id20" x="-323" y="-1606">
			<name x="-306" y="-1631">Assisting</name>
			<label kind="invariant" x="-359" y="-1589">x &lt;= tfr</label>
		</location>
		<location id="id21" x="-1998" y="-1606">
			<committed/>
		</location>
		<location id="id22" x="-1998" y="-1444">
			<name x="-1981" y="-1470">Assisting_Contact</name>
			<label kind="invariant" x="-1981" y="-1436">x &lt;= tfr
+ getDistanceCF(contacting_survivor_id,first_responder_id)
+ getDistanceCF(detected_victim_id,first_responder_id)</label>
		</location>
		<location id="id23" x="-1998" y="-960">
			<label kind="invariant" x="-1989" y="-943">x &lt;= tfr
+ getDistanceCF(contacting_survivor_id,first_responder_id)
+ getDistanceCF(detected_victim_id, first_responder_id)</label>
			<label kind="comments" x="-1981" y="-1011">If the victim dies
=&gt; Finish rescue of the contacting_survivor</label>
		</location>
		<location id="id24" x="-1734" y="-1249">
			<committed/>
		</location>
		<location id="id25" x="-1020" y="-1462">
			<name x="-1003" y="-1487">Wandering</name>
		</location>
		<init ref="id17"/>
		<transition id="id26">
			<source ref="id18"/>
			<target ref="id25"/>
			<label kind="guard" x="-1011" y="-1547">!foundVictim()</label>
		</transition>
		<transition id="id27">
			<source ref="id22"/>
			<target ref="id24"/>
			<label kind="guard" x="-1981" y="-1351">x &gt;= tfr
+ getDistanceCF(contacting_survivor_id,first_responder_id)
+ getDistanceCF(detected_victim_id,first_responder_id)</label>
			<label kind="synchronisation" x="-1981" y="-1292">rescue_completed_msg[detected_victim_id]!</label>
			<nail x="-1998" y="-1249"/>
		</transition>
		<transition id="id28">
			<source ref="id24"/>
			<target ref="id19"/>
			<label kind="synchronisation" x="-1717" y="-1241">rescue_completed_msg[contacting_survivor_id]!</label>
			<label kind="assignment" x="-1717" y="-1224">prepareNewRescue()</label>
			<nail x="-1300" y="-1249"/>
		</transition>
		<transition id="id29">
			<source ref="id25"/>
			<target ref="id19"/>
			<label kind="select" x="-1283" y="-1453">direction : int[0,3]</label>
			<label kind="guard" x="-1283" y="-1436">canMove(direction,f_position[first_responder_id])</label>
			<label kind="assignment" x="-1283" y="-1419">move(direction)</label>
			<nail x="-1300" y="-1462"/>
		</transition>
		<transition id="id30">
			<source ref="id23"/>
			<target ref="id19"/>
			<label kind="guard" x="-1283" y="-1138">x &gt;= tfr
+ getDistanceCF(contacting_survivor_id,first_responder_id)
+ getDistanceCF(detected_victim_id,first_responder_id)</label>
			<label kind="synchronisation" x="-1283" y="-1070">rescue_completed_msg[contacting_survivor_id]!</label>
			<label kind="assignment" x="-1283" y="-1045">prepareNewRescue()</label>
			<nail x="-1300" y="-960"/>
		</transition>
		<transition id="id31">
			<source ref="id22"/>
			<target ref="id23"/>
			<label kind="guard" x="-1989" y="-1138">x &lt; tfr
+ getDistanceCF(contacting_survivor_id,first_responder_id)
+ getDistanceCF(detected_victim_id,first_responder_id)</label>
			<label kind="synchronisation" x="-1989" y="-1070">casualty_msg[detected_victim_id]?</label>
		</transition>
		<transition id="id32">
			<source ref="id21"/>
			<target ref="id22"/>
			<label kind="assignment" x="-1981" y="-1546">readMessageFromContactingCivilian(),
x = 0</label>
		</transition>
		<transition id="id33">
			<source ref="id19"/>
			<target ref="id21"/>
			<label kind="synchronisation" x="-1844" y="-1598">civilian_contact_msg[first_responder_id]?</label>
		</transition>
		<transition id="id34">
			<source ref="id18"/>
			<target ref="id20"/>
			<label kind="guard" x="-824" y="-1665">foundVictim()</label>
			<label kind="synchronisation" x="-824" y="-1648">rescue_msg[detected_victim_id]!</label>
			<label kind="assignment" x="-824" y="-1631">x = 0</label>
		</transition>
		<transition id="id35">
			<source ref="id20"/>
			<target ref="id19"/>
			<label kind="guard" x="-399" y="-1810">x &lt; tfr</label>
			<label kind="synchronisation" x="-629" y="-1793">casualty_msg[detected_victim_id]?</label>
			<label kind="assignment" x="-493" y="-1776">prepareNewRescue()</label>
			<label kind="comments" x="-306" y="-1819">If the victim dies at the
exact moment in which the
first responder completes
their rescue
=&gt; The victim is saved
(And in all analogous cases)
Optimistic assumption
(x &lt; tfr, without non-det)</label>
			<nail x="-325" y="-1818"/>
			<nail x="-1300" y="-1818"/>
		</transition>
		<transition id="id36">
			<source ref="id20"/>
			<target ref="id19"/>
			<label kind="guard" x="-410" y="-1716">x &gt;= tfr</label>
			<label kind="synchronisation" x="-697" y="-1700">rescue_completed_msg[detected_victim_id]!</label>
			<label kind="assignment" x="-493" y="-1682">prepareNewRescue()</label>
			<nail x="-325" y="-1725"/>
			<nail x="-1300" y="-1725"/>
		</transition>
		<transition id="id37">
			<source ref="id19"/>
			<target ref="id18"/>
			<label kind="assignment" x="-1198" y="-1631">detect()</label>
		</transition>
		<transition id="id38">
			<source ref="id17"/>
			<target ref="id19"/>
			<label kind="synchronisation" x="-1623" y="-1708">initialization_completed?</label>
			<label kind="assignment" x="-1904" y="-1691">updateMap(FIRST_RESPONDER,f_position[first_responder_id])</label>
		</transition>
	</template>
	<template>
		<name>Civilian</name>
		<parameter>const int civilian_id, const int tv, const int tzr</parameter>
		<declaration>// ---- Private Civilian's variables ----
clock x;
int target_id = -1;
int closest_first_responder_id = -1;
int currentState = 3;

// ---- Private Civilian's variables ----

void move(int direction){
    position current_position = c_position[civilian_id];
    position new_position = getNewPosition(direction, current_position);
    // update array
    c_position[civilian_id] = new_position;
    // update map
    updateMap(FREE, current_position);
    updateMap(currentState, new_position);
}

// Checks wether there is an entity of "type" in the "radius"
bool checkNeighbor(int radius, int type){
    position current_position = c_position[civilian_id];
    int row, col;
    
    // Check all adjacent cells (including diagonals)
    for (row = current_position.r - radius; row &lt;= current_position.r + radius; row++) {
        for (col = current_position.c - radius; col &lt;= current_position.c + radius; col++) {
            
            // Check if the cell is within the grid boundaries
            if (row &gt;= 0 &amp;&amp; row &lt; N_ROW &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; N_COL &amp;&amp; row != current_position.r &amp;&amp; col != current_position.c) {
                if (map[row][col] == type) {
                    return true;
                }
            }
        }
    }
    return false;
}

// Check if the civilian is near an exit
bool amSafe() {
    return checkNeighbor(1, EXIT);
}

// Check if the civilian is near a fire
bool amVictim() {
    return checkNeighbor(1, FIRE);
}

void changeStateTo(int new_state){
    position current_position = c_position[civilian_id];
    currentState = new_state;
    updateMap(new_state, current_position);
}

// Find the closest first responder and update the private var
void findClosestFirstResponder() {
    position current_position = c_position[civilian_id];
    int closest_distance = N_ROW + N_COL + 1; // Initialize with maximum possible distance
    int i;
    for (i = 0; i &lt; N_FIRST_RESPONDER; i++) {
        position fr_position = f_position[i];

        int distance = getDistance(current_position, fr_position);
        
        if (distance &lt; closest_distance) {
            closest_distance = distance;
            closest_first_responder_id = i;
        }
    }
}

</declaration>
		<location id="id39" x="-2788" y="-935">
		</location>
		<location id="id40" x="-2380" y="-935">
			<committed/>
		</location>
		<location id="id41" x="-2380" y="-1096">
			<name x="-2439" y="-1105">Safe</name>
		</location>
		<location id="id42" x="-1716" y="-935">
			<committed/>
		</location>
		<location id="id43" x="-1716" y="-1096">
			<name x="-1700" y="-1122">Victim</name>
			<label kind="invariant" x="-1700" y="-1088">x &lt;= tv</label>
		</location>
		<location id="id44" x="-1368" y="-935">
			<name x="-1411" y="-960">Idle</name>
			<label kind="comments" x="-1351" y="-892">Will choose an urgent channel first.
Only one of the 2 channels can be active in a time instant.</label>
		</location>
		<location id="id45" x="-1717" y="-1266">
			<name x="-1751" y="-1300">Casualty</name>
		</location>
		<location id="id46" x="-2023" y="-1096">
			<label kind="invariant" x="-2048" y="-1079">x &lt;= tv</label>
		</location>
		<location id="id47" x="-1368" y="-1045">
			<committed/>
		</location>
		<location id="id48" x="-1368" y="-1309">
			<name x="-1496" y="-1334">ZeroResponder</name>
			<label kind="invariant" x="-1351" y="-1300">x &lt;= tzr + getDistanceCC(civilian_id,target_id)</label>
		</location>
		<location id="id49" x="-578" y="-1045">
			<committed/>
		</location>
		<location id="id50" x="-1368" y="-1479">
			<label kind="invariant" x="-1351" y="-1479">x &lt;= tzr + getDistanceCC(civilian_id,target_id)</label>
			<label kind="comments" x="-1717" y="-1470">If the victim dies, the zero-responder
finishes helping themselves.</label>
		</location>
		<location id="id51" x="-578" y="-1309">
			<name x="-680" y="-1334">Contacting</name>
		</location>
		<location id="id52" x="-578" y="-1147">
			<committed/>
		</location>
		<location id="id53" x="-1368" y="-1156">
			<committed/>
		</location>
		<init ref="id39"/>
		<transition id="id54">
			<source ref="id44"/>
			<target ref="id40"/>
			<label kind="select" x="-1556" y="-867">direction : int[0,3]</label>
			<label kind="guard" x="-1751" y="-850">canMove(direction,c_position[civilian_id])</label>
			<label kind="assignment" x="-1513" y="-833">move(direction)</label>
			<nail x="-1368" y="-799"/>
			<nail x="-2380" y="-799"/>
		</transition>
		<transition id="id55">
			<source ref="id51"/>
			<target ref="id41"/>
			<label kind="synchronisation" x="-893" y="-1504">rescue_completed_msg[civilian_id]?</label>
			<label kind="assignment" x="-757" y="-1487">changeStateTo(SAFE)</label>
			<nail x="-578" y="-1521"/>
			<nail x="-2380" y="-1521"/>
		</transition>
		<transition id="id56">
			<source ref="id52"/>
			<target ref="id51"/>
			<label kind="synchronisation" x="-1028" y="-1224">civilian_contact_msg[closest_first_responder_id]!</label>
			<label kind="assignment" x="-1181" y="-1207">sendMessageDouble(target_id,civilian_id,closest_first_responder_id)</label>
		</transition>
		<transition id="id57">
			<source ref="id49"/>
			<target ref="id52"/>
			<label kind="assignment" x="-961" y="-1096">target_id = readMessageSingle(civilian_id),
findClosestFirstResponder()</label>
		</transition>
		<transition id="id58">
			<source ref="id53"/>
			<target ref="id48"/>
			<label kind="synchronisation" x="-1360" y="-1258">rescue_msg[target_id]!</label>
			<label kind="assignment" x="-1360" y="-1241">x = 0</label>
		</transition>
		<transition id="id59">
			<source ref="id47"/>
			<target ref="id53"/>
			<label kind="assignment" x="-1360" y="-1122">target_id = readMessageSingle(civilian_id)</label>
		</transition>
		<transition id="id60">
			<source ref="id44"/>
			<target ref="id49"/>
			<label kind="synchronisation" x="-986" y="-926">drone_msg_contact_first_responder[civilian_id]?</label>
			<label kind="assignment" x="-790" y="-909">changeStateTo(IN_CONTACT)</label>
			<nail x="-578" y="-935"/>
		</transition>
		<transition id="id61">
			<source ref="id50"/>
			<target ref="id41"/>
			<label kind="guard" x="-2363" y="-1470">x &gt;= tzr + getDistanceCC(civilian_id,target_id)</label>
			<label kind="assignment" x="-2363" y="-1453">changeStateTo(SAFE)</label>
			<nail x="-2380" y="-1479"/>
		</transition>
		<transition id="id62">
			<source ref="id48"/>
			<target ref="id50"/>
			<label kind="guard" x="-1360" y="-1436">x &lt; tzr + getDistanceCC(civilian_id,target_id)</label>
			<label kind="synchronisation" x="-1360" y="-1419">casualty_msg[target_id]?</label>
		</transition>
		<transition id="id63">
			<source ref="id48"/>
			<target ref="id41"/>
			<label kind="guard" x="-2363" y="-1368">x &gt;= tzr + getDistanceCC(civilian_id,target_id)</label>
			<label kind="synchronisation" x="-2364" y="-1351">rescue_completed_msg[target_id]!</label>
			<label kind="assignment" x="-2363" y="-1334">changeStateTo(SAFE)</label>
			<nail x="-1368" y="-1377"/>
			<nail x="-2380" y="-1377"/>
		</transition>
		<transition id="id64">
			<source ref="id44"/>
			<target ref="id47"/>
			<label kind="synchronisation" x="-1360" y="-1003">drone_msg_zero_responder[civilian_id]?</label>
			<label kind="assignment" x="-1360" y="-986">changeStateTo(ZERO_RESPONDER)</label>
		</transition>
		<transition id="id65">
			<source ref="id46"/>
			<target ref="id41"/>
			<label kind="synchronisation" x="-2346" y="-1139">rescue_completed_msg[civilian_id]?</label>
			<label kind="assignment" x="-2346" y="-1122">changeStateTo(SAFE)</label>
		</transition>
		<transition id="id66">
			<source ref="id46"/>
			<target ref="id45"/>
			<label kind="guard" x="-2014" y="-1258">x &gt;= tv</label>
			<label kind="synchronisation" x="-2014" y="-1241">casualty_msg[civilian_id]!</label>
			<label kind="assignment" x="-2014" y="-1224">changeStateTo(CASUALITY)</label>
			<nail x="-2023" y="-1266"/>
		</transition>
		<transition id="id67">
			<source ref="id43"/>
			<target ref="id46"/>
			<label kind="synchronisation" x="-1997" y="-1139">rescue_msg[civilian_id]?</label>
			<label kind="assignment" x="-1997" y="-1122">changeStateTo(IN_ASSISTANCE)</label>
		</transition>
		<transition id="id68">
			<source ref="id43"/>
			<target ref="id45"/>
			<label kind="guard" x="-1700" y="-1215">x &gt;= tv</label>
			<label kind="assignment" x="-1700" y="-1198">changeStateTo(CASUALITY)</label>
		</transition>
		<transition id="id69">
			<source ref="id42"/>
			<target ref="id44"/>
			<label kind="guard" x="-1683" y="-960">!amVictim()</label>
		</transition>
		<transition id="id70">
			<source ref="id42"/>
			<target ref="id43"/>
			<label kind="guard" x="-1708" y="-1037">amVictim()</label>
			<label kind="assignment" x="-1708" y="-1020">changeStateTo(VICTIM), x = 0</label>
		</transition>
		<transition id="id71">
			<source ref="id40"/>
			<target ref="id42"/>
			<label kind="guard" x="-2346" y="-960">!amSafe()</label>
		</transition>
		<transition id="id72">
			<source ref="id40"/>
			<target ref="id41"/>
			<label kind="guard" x="-2371" y="-1037">amSafe()</label>
			<label kind="assignment" x="-2371" y="-1020">changeStateTo(SAFE)</label>
		</transition>
		<transition id="id73">
			<source ref="id39"/>
			<target ref="id40"/>
			<label kind="synchronisation" x="-2771" y="-986">initialization_completed?</label>
			<label kind="assignment" x="-2771" y="-969">updateMap(CIVILIAN,c_position[civilian_id])</label>
		</transition>
	</template>
	<system>// Template instantiations
initializer = Initializer();

drone0 = Drone(drone_ids[0], drone_nvs[0]);
drone1 = Drone(drone_ids[1], drone_nvs[1]);

fr0 = FirstResponder(first_responder_ids[0], first_responder_tfrs[0]);
fr1 = FirstResponder(first_responder_ids[1], first_responder_tfrs[1]);

civ0 = Civilian(civilian_ids[0], civilian_tvs[0], civilians_tzrs[0]);
civ1 = Civilian(civilian_ids[1], civilian_tvs[1], civilians_tzrs[1]);
civ2 = Civilian(civilian_ids[2], civilian_tvs[2], civilians_tzrs[2]);

// List of processes to be composed into a system
system initializer, drone0, drone1, fr0, fr1, civ0, civ1, civ2;

</system>
	<queries>
		<query>
			<formula/>
			<comment/>
		</query>
	</queries>
</nta>
