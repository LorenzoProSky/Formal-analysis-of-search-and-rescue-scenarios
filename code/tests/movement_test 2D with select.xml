<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// Place global declarations here.
const int GRID_SIZE = 3;
const int N_PERSONS = 3;

int grid[GRID_SIZE][GRID_SIZE] = {{1,0,0},{0,1,0},{0,0,1}};

typedef struct {
    int r;
    int c;
} Position;

broadcast chan init_c;

Position p_position[N_PERSONS];

Position p1;
Position p2;
Position p3;

void initialize_positions() {
    p1.r = 0;
    p1.c = 0;
    p2.r = 1;
    p2.c = 1;
    p3.r = 2;
    p3.c = 2;

    p_position[0] = p1;
    p_position[1] = p2;
    p_position[2] = p3;

}

bool sum_array(){
  int somma = 0;
  for (i : int[0,GRID_SIZE-1]) {
    for (j : int[0,GRID_SIZE-1]) {
        somma = somma + grid[i][j];
    }
  }
  if(somma == 3) return true;
  return false;

}

bool are_different(){

  Position p;
  for (i : int[0,N_PERSONS-1]) {
    p = p_position[i];
    for (j : int[0,N_PERSONS-1]) {
        if(p.r == p_position[j].r &amp;&amp; p.c == p_position[j].c &amp;&amp; i != j &amp;&amp; p.r != 0 &amp;&amp; p.c != 0) {
            return false;
        }
    }
  }
  return true;

}</declaration>
	<template>
		<name x="5" y="5">Civilian</name>
		<parameter>int person_id</parameter>
		<declaration>// Define direction constants
const int UP = 0;
const int RIGHT = 1;
const int DOWN = 2;
const int LEFT = 3;

bool can_move(int direction) {


    Position current_position = p_position[person_id];
    int new_r = current_position.r;
    int new_c = current_position.c;

    // Calculate new position based on direction
    if (direction == UP) new_r++;
    else if (direction == RIGHT) new_c++;
    else if (direction == DOWN) new_r--;
    else if (direction == LEFT) new_c--;

    // Check if new position is within grid bounds
    if (new_r &lt; 0 || new_r &gt;= GRID_SIZE || new_c &lt; 0 || new_c &gt;= GRID_SIZE) 
        return false;

    // Check if new position is empty in the grid
    if (grid[new_r][new_c] != 0) 
        return false;

    // Check if any other person is in the target position
    for (i : int[0, N_PERSONS-1]) {
        if (i != person_id &amp;&amp; 
            p_position[i].r == new_r &amp;&amp; 
            p_position[i].c == new_c) {
            return false;
        }
    }

    return true;
}

void move(int direction) {

    Position current_position = p_position[person_id];
    int new_r = current_position.r;
    int new_c = current_position.c;

    // Calculate new position based on direction
    if (direction == UP) new_r++;
    else if (direction == RIGHT) new_c++;
    else if (direction == DOWN) new_r--;
    else if (direction == LEFT) new_c--;

    // Update position
    p_position[person_id].r = new_r;
    p_position[person_id].c = new_c;

    // Update grid
    grid[new_r][new_c] = 1;  // occupy new position
    grid[current_position.r][current_position.c] = 0;  // free old position

}</declaration>
		<location id="id0" x="-1343" y="-34">
		</location>
		<location id="id1" x="-1037" y="-34">
		</location>
		<location id="id2" x="-1657" y="-34">
		</location>
		<init ref="id2"/>
		<transition id="id3">
			<source ref="id1"/>
			<target ref="id0"/>
			<nail x="-1071" y="170"/>
			<nail x="-1283" y="170"/>
		</transition>
		<transition id="id4">
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-1547" y="-59">init_c?</label>
		</transition>
		<transition id="id5">
			<source ref="id0"/>
			<target ref="id1"/>
		</transition>
		<transition id="id6">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="select" x="-1325" y="-85">direction : int[0,3]</label>
			<label kind="guard" x="-1325" y="-68">can_move(direction)</label>
			<label kind="assignment" x="-1325" y="-34">move(direction)</label>
		</transition>
	</template>
	<template>
		<name>Initializer</name>
		<location id="id7" x="0" y="0">
		</location>
		<location id="id8" x="229" y="0">
		</location>
		<init ref="id7"/>
		<transition id="id9">
			<source ref="id7"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="18" y="-17">init_c!</label>
			<label kind="assignment" x="17" y="0">initialize_positions()</label>
		</transition>
	</template>
	<system>// Place template instantiations here.
P1 = Civilian(0);
P2 = Civilian(1);
P3 = Civilian(2);
I = Initializer();

// List one or more processes to be composed into a system.
system P1, P2, P3, I;
</system>
	<queries>
		<option key="--diagnostic" value="2"/>
		<query>
			<formula>A[] sum_array()</formula>
			<comment>Verifica che i processi non possano finire sullo stesso posto.</comment>
			<result outcome="success" type="quality" timestamp="2024-06-27 10:25:11 +0200">
				<option key="--diagnostic" value="2"/>
			</result>
		</query>
		<query>
			<formula>A[] are_different()</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-06-27 10:25:07 +0200">
				<option key="--diagnostic" value="2"/>
			</result>
		</query>
		<query>
			<formula>A[] not deadlock</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2024-06-27 10:25:09 +0200">
				<option key="--diagnostic" value="2"/>
			</result>
		</query>
	</queries>
</nta>
